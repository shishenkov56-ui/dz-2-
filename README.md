Цель работы
Познакомиться с базовыми алгоритмами сортировки и поиска; дать подробную теоретическую характеристику каждого алгоритма; сравнить достоинства и недостатки; привести реализации на Python и C++.
Краткая теоретическая справка
Алгоритмы сортировки упорядочивают элементы в массиве или списке по определённому критерию (обычно по возрастанию или убыванию). В отчёте рассматриваются классические алгоритмы сортировки: Selection (выбором), Bubble (обменом), Insertion (вставками), Merge (слиянием), Shell, Quick (быстрая), Heap (пирамида). Также рассмотрены алгоритмы поиска: последовательный (linear), бинарный, интерполяционный и поиск по Фибоначчи.
Сортировка выбором (Selection Sort)
Идея: на каждом шаге алгоритм ищет минимальный (или максимальный) элемент в неотсортированной части массива и помещает его в конец отсортированной части. Проходы выполняются по всему массиву, постепенно увеличивая отсортованную часть.
Особенности и анализ:
- Количество сравнений приблизительно n*(n-1)/2 — квадратичная сложность.
- Количество пересылок (swap) = n в худшем случае — относительно мало по сравнению с некоторыми другими O(n^2) алгоритмами.
- Алгоритм нестабилен (потеря относительного порядка равных элементов) в стандартной реализации.
- Простота реализации и небольшой набор операций делают его пригодным для обучения и для небольших наборов данных.
- Применение: когда важен минимальный объём перестановок (swap) и данные малы; редко используется в реальных системах.
Оценка сложности и свойства: Time: O(n^2) в любом случае; Space: O(1); Стабильность: нестабилен.
Сортировка обменом (Bubble Sort)
Идея: повторно проходить по массиву и соседними обменами (swap) перемещать большие элементы к концу (или маленькие к началу). Каждый проход «всплывают» (bubble) элементы в нужное место.
Особенности и анализ:
- Простейшая и наглядная сортировка; хороша для демонстрации обменов.
- Классическая версия — O(n^2) сравнений и обменов. Оптимизированная версия отслеживает, были ли обмены — если нет, массив уже отсортирован.
- Стабильна (не меняет порядок равных элементов) в стандартной реализации.
- Применение: обучающие цели, почти отсортированные массивы (с оптимизацией) — тогда сложность близка к O(n).
- На практике редко используется для больших массивов.
Оценка сложности и свойства: Time: O(n^2) худший/средний; O(n) лучший (с оптимизацией); Space: O(1); Стабильность: стабильна.
Сортировка вставками (Insertion Sort)
Идея: строить отсортированную часть массива постепенно: взять следующий элемент и «вставить» его в правильную позицию в уже отсортированной части, сдвигая элементы вправо.
Особенности и анализ:
- Эффективна для маленьких массивов и для массивов, которые уже почти отсортированы.
- В худшем и среднем — O(n^2), но в лучшем (уже отсортированный массив) — O(n).
- Стабильна и выполняется на месте (in-place).
- Часто используется как часть гибридных алгоритмов (например, в Timsort или в оптимизированных реализациях Quick/Merge для сортировки маленьких подмассивов).
- Простая реализация и малые накладные расходы делают её полезной в практических реализациях.
Оценка сложности и свойства: Time: O(n^2) худший/средний; O(n) лучший; Space: O(1); Стабильность: стабильна.
Сортировка слиянием (Merge Sort)
Идея: «разделяй и властвуй» — рекурсивно разбивать массив пополам до единичных элементов, затем сливать отсортированные части, получая полностью отсортированный массив.
Особенности и анализ:
- Гарантированная временная сложность O(n log n) в любом случае.
- Дополнительная память O(n) требуется для временных массивов при слиянии (не in-place в стандартной реализации).
- Алгоритм стабильный (сохранение относительного порядка равных элементов) при корректной реализации.
- Хорош для сортировки внешней памяти (внешняя сортировка) и больших массивов; широко используется в стандартных библиотеках (реализуется вариация с оптимизациями).
- Недостаток — потребление памяти и рекурсивные вызовы (можно делать iterative bottom-up реализацию).
- Часто комбинируется с сортировкой вставками для маленьких подмассивов.
Оценка сложности и свойства: Time: O(n log n) во всех случаях; Space: O(n); Стабильность: стабильна.
Сортировка Шелла (Shell Sort)
Идея: обобщение сортировки вставками — сравнивать и перемещать элементы, находящиеся на некотором расстоянии (gap), уменьшающемcя по мере прогрессирования алгоритма. Это позволяет эффективно перемещать элементы на большие расстояния в начале и уменьшить количество сдвигов.
Особенности и анализ:
- Сложность зависит от выбранной последовательности шагов (gap). Для некоторых последовательностей оценка может быть ~O(n^(3/2)) или лучше; в худших случаях O(n^2).
- Работает inplace и не требует дополнительной памяти.
- Не является стабильной в стандартных реализациях.
- Применяется, когда нужно улучшить вставки без дополнительной памяти; на практике результаты зависят от выбора gap-последовательности (Knuth, Ciura и др.).
Оценка сложности и свойства: Time: зависит от gap — от O(n) до O(n^2) (обычно ~O(n^(3/2)) для хороших последовательностей); Space: O(1); Стабильность: нестабильна.
Быстрая сортировка (Quick Sort)
Идея: выбрать опорный элемент (pivot), разделить массив так, чтобы слева оказались элементы ≤ pivot, справа — ≥ pivot, затем рекурсивно отсортировать обе части. Разделение может выполняться по-разному (Lomuto, Hoare).
Особенности и анализ:
- В среднем даёт время O(n log n) и часто быстрее Merge/Heap на практике из-за меньших констант и локальности памяти.
- В худшем случае (например, уже отсортированный массив и плохой выбор pivot) — O(n^2). Чтобы смягчить худший случай, используют случайный выбор pivot или медиану трёх.
- Выполняется in-place (варианты), но нестабилен в стандартной реализации.
- Рекурсивная глубина — O(log n) в среднем, O(n) в худшем. В практических реализациях используют хвостовую рекурсию и сортировку вставками для маленьких подмассивов.
- Широко используется в стандартных библиотеках (реализации часто имеют дополнительные оптимизации).

Оценка сложности и свойства: Time: O(n log n) среднее; O(n^2) худший; Space: O(log n) средний (рекурсивный стек); Стабильность: нестабилен.
Пирамидальная сортировка (Heap Sort)
Идея: представить массив как бинарную кучу (heap), построить max-heap, затем последовательно извлекать максимум (корень) и помещать его в конец массива, уменьшая размер кучи.
Особенности и анализ:
- Время O(n log n) в худшем/среднем/лучшем — предсказуемая производительность.
- Выполняется in-place и требует O(1) дополнительной памяти.
- Нестабилен (обычно) — при перестановках теряется относительный порядок равных элементов.
- На практике часто уступает QuickSort по средней скорости из‑за худшей локальности памяти.
- Применение: когда требуется гарантия времени выполнения и ограниченная дополнительная память.
Оценка сложности и свойства: Time: O(n log n) во всех случаях; Space: O(1); Стабильность: нестабилен.
Бинарный поиск (Binary Search)
Идея: применяется к отсортированным массивам. На каждом шаге сравниваем искомое значение с серединным элементом и отбросаем половину массива.
Особенности и анализ:
- Время O(log n) — очень эффективно на больших отсортированных массивах.
- Требуется предварительно отсортированный массив; для динамических данных поддерживать упорядоченность может быть дорого.
- Бинарный поиск можно реализовать рекурсивно или итеративно; при работе с плавающей арифметикой важно избегать переполнения при вычислении mid (использовать lo + (hi-lo)//2).

Оценка сложности и свойства: Time: O(log n); Space: O(1) итеративно или O(log n) рекурсивно.
Интерполирующий поиск (Interpolation Search)
Идея: предсказывать позицию искомого элемента в массиве по линейной интерполяции, исходя из крайних значений. Особенно эффективен на равномерно распределённых данных.
Особенности и анализ:
- При равномерном распределении достигает времени ~O(log log n).
- В худшем случае (например, экстремально неравномерное распределение) — O(n).
- Требует, чтобы значения были числовыми и массив был отсортирован.
- Практическая эффективность чувствительна к распределению данных.
Оценка сложности и свойства: Time: O(log log n) при равномерном распределении; O(n) в худшем; Space: O(1).
Поиск по Фибоначчи (Fibonacci Search)
Идея: аналог бинарного поиска, но использует числа Фибоначчи для выбора пробных индексов. Подход удобен на системах, где доступ к элементам массива имеет различные стоимости или для определённых поисковых паттернов.
Особенности и анализ:
- Время O(log n) — приближённо аналогично бинарному поиску.
- Требует генерации чисел Фибоначчи до значения ≥ n.
- На практике бинарный поиск обычно предпочтительнее из-за простоты и лучшей локальности памяти, но Fibonacci search иногда используется в учебных задачах и специфических сценариях.
Оценка сложности и свойства: Time: O(log n); Space: O(1).
Выводы
В отчёте представлены расширенные теоретические описания классических алгоритмов сортировки и поиска, их достоинства, недостатки и рекомендации по применению. Выбор алгоритма зависит от размера данных, требований к памяти, стабильности и распределения входных данных.
